# .bash/main - Main Bash configuration
#
# This file is sourced from ~/.profile to pull in all custom shell configurations.
#
# Large portions taken from a variety of sources, including the dotfiles repos of
# github.com/{isaacs,rtomayko,twerth,sontek} to name a few.
#

main()
{
# try to avoid polluting the global namespace with lots of garbage.
# the *right* way to do this is to have everything inside functions,
# and use the "local" keyword.  But that would take some work to
# reorganize all my old messes.  So this is what I've got for now.
__garbage_list=""
__garbage () {
  local i
  if [ $# -eq 0 ]; then
    for i in ${__garbage_list}; do
      unset $i
    done
    unset __garbage_list
  else
    for i in "$@"; do
      __garbage_list="${__garbage_list} $i"
    done
  fi
}
__garbage __garbage


##
# Path utilities.

__garbage __set_path
__set_path () {
  local var="$1"
  local orig=$(eval 'echo $'$var)
  IFS=:
  orig=($orig)
  local p="$2"

  local path_elements=($p)
  unset IFS
  p=""
  local i
  local fixed
  for i in "${orig[@]}"; do
    if [ -d "$i" ]; then
      fixed="$fixed:$i"
    fi
  done
  fixed=" ${fixed//:/ : } :"
  for i in "${path_elements[@]}"; do
    if [ -d "$i" ]; then
      p="$p:$i"
      # strip out from the original set.
      fixed=${fixed/ $i :/}
    fi
  done
  fixed=${fixed// :/:}
  fixed=${fixed//: /:}
  fixed=${fixed%:}
  p="${p/:/}:$(echo ${fixed/:/})"
  export $var="$(echo $p)"
}

__garbage __form_paths
local path_roots=( "$HOME/" "$HOME/local/" /usr/local/ /opt/local/ /usr/ /opt/ / )
__form_paths () {
  local r p paths
  paths=""
  for r in "${path_roots[@]}"; do
    for p in "$@"; do
      paths="$paths:$r$p"
    done
  done
  echo ${paths/:/} # remove the first :
}

__set_path PATH ".:$(__form_paths bin sbin)"
__set_path LD_LIBRARY_PATH "$(__form_paths lib)"
# TODO: Needs mingw path fixup
#__set_path CLASSPATH "."
__set_path CDPATH ".:..:$HOME/git:$HOME/hg:$HOME/svn:$HOME"


##
# Shell and host environment.

# detect interactive shell
case "$-" in
  *i*) INTERACTIVE=yes ;;
  *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
  -*) LOGIN=yes ;;
  *)  unset LOGIN ;;
esac

# detect remote shell
if [ -n "$SSH_CONNECTION" ]; then
  REMOTE=yes
else
  unset REMOTE
fi

# Kernel and system identification.
# Don't set any variables named OS, OS_TYPE, or HOSTTYPE, these may already exist.
# Strip any numbers trailing the kernel, i.e. remove "32..." from "mingw32..."
HOST_OS=`uname -s | sed -e 's/  */-/g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/;s/[0-9].*//'`
HOST_MACHINE=`uname -m | sed -e 's/  */-/g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
HOST_VERSION=`uname -r`; HOST_VERSION=`expr "$HOST_VERSION" : '[^0-9]*\([0-9]*\.[0-9]*\)'`
HOST_PLATFORM="${HOST_MACHINE}-${HOST_OS}-${HOST_VERSION}"


##
# Locale

: ${LANG:="en_US.UTF-8"}
: ${LANGUAGE:="en"}
: ${LC_CTYPE:="en_US.UTF-8"}
: ${LC_ALL:="en_US.UTF-8"}
export LANG LANGUAGE LC_CTYPE LC_ALL


##
# Various shell options

export HISTSIZE=10000
export HISTFILESIZE=1000000000
export HISTCONTROL=ignoreboth
export HISTIGNORE="&:cd:ls:ll:la:lal:[bf]g:exit:clear:pwd:* --help"
export HISTTIMEFORMAT='%F %T '

if [ -n "$BASH" ]; then
  # see http://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin
  shopt -s cdspell                  # fix minor cd errors
  shopt -s checkhash                # check that a command exists in the hash table before executing it
  shopt -s checkwinsize             # update LINES and COLUMNS after each command to detect window size changes
  shopt -s cmdhist                  # save a multi-line command in a single history entry
  shopt -s expand_aliases           # expand aliases when not interactive
  shopt -s histappend               # append history instead of overwriting it
  shopt -s hostcomplete             # attempt hostname completion (on words containing '@')
  shopt -s nocaseglob               # case-insensitive filename match
  shopt -s no_empty_cmd_completion  # don't search PATH for command completion if the line is empty
fi


##
# ls

# if the dircolors utility is available, set that up to
__garbage __dircolors COLORS
__dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$__dircolors" && {
  COLORS=/etc/DIR_COLORS
  test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
  test -e "$HOME/.dir_colors"       && COLORS="$HOME/.dir_colors"
  test ! -e "$COLORS"               && COLORS=
  eval `$__dircolors --sh "$COLORS"`
}

# Setup the options that are always passed to ls
# Print sizes in human-readable format; don't list groups.
LS_COMMON="-hG"

# Does ls support --color?
if (ls --color) &> /dev/null; then
  LS_COMMON="$LS_COMMON --color=auto"
else
  # No color, so put a slash at the end of directory names, etc. to differentiate.
  LS_COMMON="$LS_COMMON -F"
fi

# Ignore NTUSER.DAT files on Windows
if [[ "$HOST_OS" == "mingw" ]]; then
  LS_COMMON="$LS_COMMON -I NTUSER.DAT\*"
fi

test -n "$LS_COMMON" &&
alias ls="command ls $LS_COMMON"
alias ll="ls -l"
alias la="ls -a"
alias lal="ll -a"


##
# EDITOR and PAGER

EDITOR=vim
export EDITOR

if [ -n "$(command -v less)" ]; then
  PAGER="less"
  # Less PAGER opts: Clear screen to repaint, ignore case in searches w/no uppercase, use the long prompt,
  # output "raw" control chars, chop long lines, set horizonatal scroll amount to 4 characters
  LESS="-ciMrS -#4"
  # Less MANPAGER opts: Same as above except don't output "raw" control chars and squeeze multiple blank lines
  MANPAGER="less -ciRs -#4"
else
  PAGER=more
  MANPAGER=more
fi
export PAGER MANPAGER LESS

alias l=$PAGER


##
# Terminal

if [ -n "$REMOTE" ]; then
  # Fix the terminal when shelling in from MSYS or Cygwin.
  case "$TERM" in
    msys*)
      # TODO: Make sure the host isn't MSYS or Cygwin.
      export TERM=xterm
      ;;
  esac
fi


##
# Prompt

# Only set the prompt if the shell is interactive.
# The bash-complete function will set BASH_COMPLETE_INVOKE to prevent the prompt from being set;
# this is so it can detect the output of shell completion.
if [ -n "$INTERACTIVE" -a -z "$BASH_COMPLETE_INVOKE" ]; then
  # Colors defined by the Solarized color scheme.
  #__garbage NO_COLOR RED ORANGE GREEN YELLOW BLUE MAGENTA VIOLET CYAN WHITE
  NO_COLOR='\033[00m'
  RED='\033[00;31m'
  ORANGE='\033[01;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  BLUE='\033[00;34m'
  MAGENTA='\033[00;35m'
  VIOLET='\033[01;35m'
  CYAN='\033[00;36m'
  WHITE='\033[01;37m'

  PATH_COLOR=$YELLOW
  HOST_COLOR=$VIOLET

  function __prompt()
  {
    local cwd=${PWD/$HOME/\~}

    if [ -z "$1" ]; then
      echo -e "$(__prompt title)\n$(__prompt host):$(__prompt path)$(__prompt git)$(__prompt venv)"
    fi

    case "$1" in
      title)
        echo -ne "\033]0;$HOSTNAME:$cwd\007"
        ;;

      path)
        local path=$cwd
        if [ ${#path} -gt 40 ]; then
          local d=$(basename "$path")
          path=$(dirname "$path")
          local i=$[ ${#path} - 40 ]
          path=...${path:$i}/$d
        fi
        echo -ne "${PATH_COLOR}${path}${NO_COLOR}"
        ;;

      host)
        local user=${USER:-$USERNAME}
        local host=${HOSTNAME%%.*}
        echo -ne "${HOST_COLOR}${user}@${host}${NO_COLOR}"
        ;;

      time)
        echo -ne "[${GREEN}$(date +"%R")${NO_COLOR}]"
        ;;

      git)
        # From bronson's dotfiles:
        local STATE_COLOR=$WHITE
        local unclean_state="${STATE_COLOR}*"
        local changes_to_push="${STATE_COLOR}↑"
        local changes_to_pull="${STATE_COLOR}↓"
        local changes_to_push_and_pull="${STATE_COLOR}↕"

        local git_status="$(git status 2> /dev/null)"
        local branch_pattern="^# On branch ([[:graph:]]*)"
        local remote_pattern="# Your branch is (.*) of"
        local diverge_pattern="# Your branch and (.*) have diverged"

        if [[ ! ${git_status} =~ "working directory clean" ]]; then
          local state="$unclean_state"
        fi

        # add an else if or two here if you want to get more specific
        if [[ ${git_status} =~ ${remote_pattern} ]]; then
          if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
            local remote="$changes_to_push"
          else
            local remote="$changes_to_pull"
          fi
        fi
        if [[ ${git_status} =~ ${diverge_pattern} ]]; then
          local remote="$changes_to_push_and_pull"
        fi
        if [[ ${git_status} =~ ${branch_pattern} ]]; then
          local branch=${BASH_REMATCH[1]}
          local git_branch=" (${branch})${remote}${state}"
        fi

        echo -ne "${MAGENTA}${git_branch}${NO_COLOR}"
        ;;

      venv)
        # From mitsuhiko's dotfiles:
        local ENV_NAME
        local folder
        if [ x"$VIRTUAL_ENV" != x ]; then
          if [[ "$VIRTUAL_ENV" == *.virtualenvs/* || "$VIRTUAL_ENV" == *.virtualenvs\\* ]]; then
            ENV_NAME=`basename "${VIRTUAL_ENV}"`
          else
            folder=`dirname "${VIRTUAL_ENV}"`
            ENV_NAME=`basename "$folder"`
          fi
          echo -ne " ${WHITE}workon ${GREEN}${ENV_NAME}${NO_COLOR}"
        fi
        ;;

      color)
        local color
        if [ $__prompt_status -eq 0 ]; then
          color="${NO_COLOR}"
        else
          color="${RED}"
        fi
        echo -ne "$color"
        ;;
    esac
  }

  PROMPT_COMMAND="__prompt_status=\$?; history -a; __prompt"
  PS1="\[\$(__prompt color)\]\$\[${NO_COLOR}\] "
fi


##
# Command completion

# Only source completion if the shell is interactive.
if [ -n "$INTERACTIVE" -a -z "$BASH_COMPLETION" ]; then
  bash=${BASH_VERSION%.*}; bmajor=${bash%.*}; bminor=${bash#*.}
  if [ $bmajor -gt 1 ]; then
    # Search for a bash_completion file to source.
    for f in /usr/local/etc/bash_completion \
             /usr/pkg/etc/bash_completion \
             /opt/local/etc/bash_completion \
             /etc/bash_completion
    do
      if [ -f $f ]; then
        . $f
        break
      fi
    done
  fi
  unset bash bmajor bminor
  if [ -z "$BASH_COMPLETION" ]; then
    # If there's no system-wide bash_completion, source the user one ourselves.
    [ -f ~/.bash_completion ] && . ~/.bash_completion
  fi
fi

# List of file prefixes and extensions to ignore when doing autocomplete.
# Separate each extension with ':'.
export FIGNORE=.pyc

if [[ "$HOST_OS" == "mingw" ]]; then
  # Ignore the long and unused NTUSER.DAT{* files on Windows.
  export FIGNORE="$FIGNORE:.TM.blf:.regtrans-ms"
fi


##
# ssh-agent

# Code for ~/.ssh/environment is originally from http://www.cygwin.com/ml/cygwin/2001-06/msg00537.html.

export SSH_ENV="$HOME/.ssh/environment"

__garbage __start_ssh_agent
__start_ssh_agent()
{
  ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
  chmod 600 "${SSH_ENV}"
  . "${SSH_ENV}" > /dev/null
  if [ -n "$INTERACTIVE" ]; then
    # TODO: Not sure how useful this is when ssh-agent isn't already running, and we're not interactive...
    ssh-add
  fi
}

if [ -f "${SSH_ENV}" ]; then
  . "${SSH_ENV}" > /dev/null
  # TODO: Move ps detection elsewhere.
  __garbage __ps_full
  __ps_full=-x
  [ -n "$WINDIR" ] && __ps_full=
  ps $__ps_full | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
    __start_ssh_agent
  }
else
  [ -d "$HOME/.ssh" ] || mkdir "$HOME/.ssh"
  __start_ssh_agent
fi


##
# Functions and aliases

[ -f ~/.bash/functions ] && . ~/.bash/functions
[ -f ~/.bash/aliases ] && . ~/.bash/aliases


##
# Load host OS configuration

[ -f "$HOME/.bash/os_${HOST_OS}" ] && . "$HOME/.bash/os_${HOST_OS}"


##
# Initialization scripts

__garbage MAIN_BASH_INIT_DIR
MAIN_BASH_INIT_DIR=~/.bash/init.d

if [[ -d "$MAIN_BASH_INIT_DIR" && -r "$MAIN_BASH_INIT_DIR" \
      && -x "$MAIN_BASH_INIT_DIR" ]]; then
  for i in "$MAIN_BASH_INIT_DIR"/*; do
    [[ -f "$i" && -r "$i" ]] && . "$i"
  done
fi
unset i

# Collect local variables and functions.
__garbage
}

main
unset main

# ex: ts=2 sw=2 et filetype=sh
