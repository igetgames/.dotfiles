# .bash/main - Main Bash configuration
#
# This file is sourced from ~/.profile to pull in all custom shell configurations.
#
# Large portions taken from a variety of sources, including the dotfiles repos of
# github.com/{isaacs,rtomayko,twerth,sontek} to name a few.
#

main()
{
# try to avoid polluting the global namespace with lots of garbage.
# the *right* way to do this is to have everything inside functions,
# and use the "local" keyword.  But that would take some work to
# reorganize all my old messes.  So this is what I've got for now.
__garbage_list=""
__garbage () {
  local i
  if [ $# -eq 0 ]; then
    for i in ${__garbage_list}; do
      unset $i
    done
    unset __garbage_list
  else
    for i in "$@"; do
      __garbage_list="${__garbage_list} $i"
    done
  fi
}
__garbage __garbage


##
# Path utilities.

__garbage __set_path
__set_path () {
  local var="$1"
  local orig=$(eval 'echo $'$var)
  IFS=:
  orig=($orig)
  local p="$2"

  local path_elements=($p)
  unset IFS
  p=""
  local i
  local fixed
  for i in "${orig[@]}"; do
    if [ -d "$i" ]; then
      fixed="$fixed:$i"
    fi
  done
  fixed=" ${fixed//:/ : } :"
  for i in "${path_elements[@]}"; do
    if [ -d "$i" ]; then
      p="$p:$i"
      # strip out from the original set.
      fixed=${fixed/ $i :/}
    fi
  done
  fixed=${fixed// :/:}
  fixed=${fixed//: /:}
  # put the original at the front, but only the ones that aren't already present
  # This preserves the intended ordering, and allows env hijacking tricks like
  # nave and other subshell programs use.
  p="${fixed/:/}${p/:/}"
  export $var="$(echo $p)"
}

__garbage __form_paths
local path_roots=( "$HOME/" "$HOME/local/" /usr/local/ /opt/local/ /usr/ /opt/ / )
__form_paths () {
  local r p paths
  paths=""
  for r in "${path_roots[@]}"; do
    for p in "$@"; do
      paths="$paths:$r$p"
    done
  done
  echo ${paths/:/} # remove the first :
}

__set_path PATH "$(__form_paths bin sbin)"
__set_path LD_LIBRARY_PATH "$(__form_paths lib)"
# TODO: Needs mingw path fixup
#__set_path CLASSPATH "."
__set_path CDPATH ".:..:$HOME/git:$HOME/hg:$HOME"


##
# Shell and host environment.

# detect interactive shell
case "$-" in
  *i*) INTERACTIVE=yes ;;
  *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
  -*) LOGIN=yes ;;
  *)  unset LOGIN ;;
esac

# detect remote shell
if [ -n "$SSH_CONNECTION" ]; then
  REMOTE=yes
else
  unset REMOTE
fi


##
# Various shell options

export HISTSIZE=10000
export HISTFILESIZE=1000000000
export HISTCONTROL=ignoreboth
export HISTIGNORE="&:cd:ls:ll:[bf]g:exit"

if [ -n "$BASH" ]; then
  # see http://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin
  shopt -s cdspell                  # fix minor cd errors
  shopt -s checkhash                # check that a command exists in the hash table before executing it
  shopt -s checkwinsize             # update LINES and COLUMNS after each command to detect window size changes
  shopt -s cmdhist                  # save a multi-line command in a single history entry
  shopt -s expand_aliases           # expand aliases when not interactive
  shopt -s histappend               # append history instead of overwriting it
  shopt -s hostcomplete             # attempt hostname completion (on words containing '@')
  shopt -s nocaseglob               # case-insensitive filename match
  shopt -s no_empty_cmd_completion  # don't search PATH for command completion if the line is empty
fi


##
# ls

# if the dircolors utility is available, set that up to
__garbage __dircolors
__dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$dircolors" && {
  COLORS=/etc/DIR_COLORS
  test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
  test -e "$HOME/.dircolors"        && COLORS="$HOME/.dircolors"
  test ! -e "$COLORS"               && COLORS=
  eval `$__dircolors --sh $COLORS`
}

# Setup the options that are always passed to ls
LS_COMMON="-hBG"

# Does ls support --color?
if (ls --color) &> /dev/null; then
  LS_COMMON="$LS_COMMON --color=auto"
else
  # No color, so put a slash at the end of directory names, etc. to differentiate.
  LS_COMMON="$LS_COMMON -F"
fi

test -n "$LS_COMMON" &&
alias ls="command ls $LS_COMMON"
alias ll="ls -l"
alias la="ls -a"
alias lal="ll -a"


# Collect local variables and functions.
__garbage
}

main
unset main

# ex: ts=2 sw=2 et filetype=sh
